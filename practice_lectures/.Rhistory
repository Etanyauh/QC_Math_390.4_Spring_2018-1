lik_k = function(k){
-(sum(e^k * log_e) / sum(e^k) - 1 / k - 1 / n * sum(log_e))
}
n = length(e)
log_e = log(e)
opt_result = optim(6, lik_k, method = "Brent", lower = 1e-3, upper = 10)
opt_result$value
opt_result$par
lik_k = function(k){
-(sum(e^k * log_e) / sum(e^k) - 1 / k - 1 / n * sum(log_e))
}
n = length(e)
log_e = log(e)
opt_result = optim(6, lik_k, method = "Brent", lower = 1e-3, upper = 100)
opt_result$value
opt_result$par
lik_k = function(k){
-(sum(e^k * log_e) / sum(e^k) - 1 / k - 1 / n * sum(log_e))
}
n = length(e)
log_e = log(e)
opt_result = optim(6, lik_k, method = "Brent", lower = 1e-3, upper = 1000)
opt_result$value
opt_result$par
ggplot(data.frame(x_grid, y_grid)) + geom_point()
x_grid = seq(0, 10, length.out = 1e5)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid)) + geom_point()
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
x_grid = seq(0, 1, length.out = 1e5)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
x_grid = seq(0, 0.01, length.out = 1e4)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
yhat
coef(mod)
exp(cbind(1, lung_dead) %*% coef(mod))
exp(as.matrix(cbind(1, lung_dead)) %*% coef(mod))
X = as.matrix(cbind(1, lung_dead))
dim(X)
length(coef(mod))
head(X)
X = lung_dead
X$time = NULL
X$status = NULL
X = cbind(1,X)
exp(as.matrix(cbind(1, lung_dead)) %*% coef(mod))
exp(X %*% coef(mod))
class(X)
exp(as.matrix(X) %*% coef(mod))
yhat
lik_k = function(k){
e_to_the_k = e^(1 / k)
-(sum(e_to_the_k * log_e) / sum(e_to_the_k) - k - 1 / n * sum(log_e))
}
n = length(e)
log_e = log(e)
opt_result = optim(6, lik_k, method = "Brent", lower = 1e-3, upper = 1000)
opt_result$value
opt_result$par
x_grid = seq(0, 0.01, length.out = 1e4)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
e_to_the_k
e_to_the_k = e^(1 / k)
e_to_the_k
-(sum(e_to_the_k * log_e) / sum(e_to_the_k) - k - 1 / n * sum(log_e))
k
x_grid = seq(0.01, 4, length.out = 1e4)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
x_grid = seq(0.01, 100, length.out = 1e4)
y_grid = lik_k(x_grid)
ggplot(data.frame(x_grid, y_grid), aes(x_grid, y_grid)) + geom_point()
summary(mod)
mod_scale_one = survreg(Surv(time, status) ~ ., dist = 'weibull', data = lung_dead, scale = 1)
summary(mod_scale_one)
exp(as.matrix(X) %*% coef(mod_scale_one))
yhat
gamma(1 + 1/ .68)
4.996951/4.82
savehistory("C:/Users/Kapelner/workspace/QC_Math_390.4_Spring_2018/practice_lectures/history.Rhistory")
head(diamonds)
indices = sample(1 : nrow(X), 2000)
indices = sample(1 : nrow(diamonds), 2000)
length(unique(indicies))
length(unique(indices))
y = diamonds$price
X=model.matrix(price~., diamonds)
head(X)
Xinv = solve(t(x) %*% X)
Xinv = solve(t(X) %*% X)
H = X %*% solve(t(X) %*% X) %*% t(X)
QR=qr(X)
Q=qr.q(QR)
Q=qr.Q(QR)
R=qr.R(QR)
lm(price ~ carat + depth, diamonds) #using a subset of the features
lm(price ~ ., diamonds) #using a subset of the features
lm(price ~ poly(carat, 2) + poly(depth, 2), diamonds) #using some polynomial terms
lm(price ~ . * ., diamonds) #using all interactions
mod1 = lm(price ~ carat + depth, diamonds) #using a subset of the features
mod2 = lm(price ~ ., diamonds) #using a subset of the features
mod3 = lm(price ~ poly(carat, 2) + poly(depth, 2), diamonds) #using some polynomial terms
mod4 = lm(price ~ . * ., diamonds) #using all interactions
coef(mod1)
?sample
n = nrow(diamonds)
K = 5
test_indices = sample(1 : n, size = n * 1 / K)
master_train_indices = setdiff(1 : n, test_indices)
select_indices = sample(master_train_indices, size = n * 1 / K)
n = nrow(diamonds)
K = 5
test_indices = sample(1 : n, size = n * 1 / K)
master_train_indices = setdiff(1 : n, test_indices)
select_indices = sample(master_train_indices, size = n * 1 / K)
train_indices = setdiff(master_train_indices, select_indices)
rm(master_train_indices)
pacman::p_load(test_that)
pacman::p_load(testthat)
expect_equal(n, length(train_indices) + length(select_indices) + length(test_indices))
expect_equal(1 : n, sort(c(train_indices, select_indices, test_indices)))
?expect_equal
all.equal(c(1,2), c(1,2,3))
X = diamonds[, -c("price")]
X = diamonds[, -"price"]
X$price = NULL
X = diamonds
X$price = NULL
n = nrow(diamonds)
K = 5
test_indices = sample(1 : n, size = n * 1 / K)
master_train_indices = setdiff(1 : n, test_indices)
select_indices = sample(master_train_indices, size = n * 1 / K)
train_indices = setdiff(master_train_indices, select_indices)
rm(master_train_indices)
#make sure we did this right:
pacman::p_load(testthat)
expect_equal(1 : n, sort(c(train_indices, select_indices, test_indices)))
y = diamonds$price
X = diamonds
X$price = NULL
Xtrain = X[train_indices, ]
ytrain = y[train_indices]
Xselect = X[select_indices, ]
yselect = y[select_indices]
Xtest = X[test_indices, ]
ytest = y[test_indices]
rm(test_indices, select_indices, train_indices, X, y)
n = nrow(diamonds)
K = 5
test_indices = sample(1 : n, size = n * 1 / K)
master_train_indices = setdiff(1 : n, test_indices)
select_indices = sample(master_train_indices, size = n * 1 / K)
train_indices = setdiff(master_train_indices, select_indices)
rm(master_train_indices)
#make sure we did this right:
pacman::p_load(testthat)
expect_equal(1 : n, sort(c(train_indices, select_indices, test_indices)))
diamonds_train = diamonds[train_indices, ]
diamonds_select = diamonds[select_indices, ]
diamonds_test = diamonds[test_indices, ]
rm(test_indices, select_indices, train_indices)
mod1 = lm(price ~ carat + depth, diamonds_train) #using a subset of the features
mod2 = lm(price ~ ., diamonds_train) #using a subset of the features
mod3 = lm(price ~ poly(carat, 2) + poly(depth, 2), diamonds_train) #using some polynomial terms
mod4 = lm(price ~ . * ., diamonds_train) #using all interactions
yhat_mod1 = predict(mod1, diamonds_select)
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select)
)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select)
)
s_e_s
yhat_mod1 = predict(mod1, diamonds_select)
yhat_mod2 = predict(mod2, diamonds_select)
yhat_mod3 = predict(mod3, diamonds_select)
yhat_mod4 = predict(mod4, diamonds_select)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select),
sd(yhat_mod1 - y_select)
)
s_e_s
yhat_mod1 = predict(mod1, diamonds_select)
yhat_mod2 = predict(mod2, diamonds_select)
yhat_mod3 = predict(mod3, diamonds_select)
yhat_mod4 = predict(mod4, diamonds_select)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod2 - y_select),
sd(yhat_mod3 - y_select),
sd(yhat_mod4 - y_select)
)
s_e_s
which.min(s_e_s)
names(s_e_s) = c("mod1", "mod2", "mod3", "mod4")
which.min(s_e_s)
s_e_s
names(which.min(s_e_s))
s_e_s
names(s_e_s) = paste("mod", 1 : 4)
s_e_s
names(s_e_s) = paste("mod", 1 : 4, collapse = "")
s_e_s
names(s_e_s) = paste("mod", 1 : 4, sep = "")
s_e_s
base = ggplot(diamonds, aes(x = carat, y = price))
base + geom_point()
mod5 = lm(price ~ . + carat * color + carat * depth + poly(carat, 2) + poly(depth, 2), diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
mod5 = lm(price ~
. +
carat * color +
carat * depth +
poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5
table(diamonds$color, diamonds$depth)
table(diamonds$color, diamonds$clarity)
mod5 = lm(price ~
. +
carat * depth +
poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth -
color,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5
mod5 = lm(price ~
. +
carat * color +
carat * depth -
# poly(carat, 2, raw = TRUE) +
# poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
str(diamonds)
mod5 = lm(price ~
. +
carat * color +
carat * depth +
poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train)
mod5
mod5 = lm(price ~
. +
carat * color +
carat * depth +
poly(carat, 2) +
poly(depth, 2) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5
mod5 = lm(price ~
. +
carat * color +
carat * depth +
# poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
yhat_mod1 = predict(mod1, diamonds_select)
yhat_mod2 = predict(mod2, diamonds_select)
yhat_mod3 = predict(mod3, diamonds_select)
yhat_mod4 = predict(mod4, diamonds_select)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod2 - y_select),
sd(yhat_mod3 - y_select),
sd(yhat_mod4 - y_select)
)
names(s_e_s) = paste("mod", 1 : 4, sep = "")
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
# poly(carat, 2, raw = TRUE) +
poly(depth, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
poly(carat, 2, raw = TRUE) -
carat -
depth,
diamonds_train) #I subtracted carat and depth because they are contained in the polynomial terms
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
carat * carat +
depth * depth
diamonds_train)
mod5 = lm(price ~
. +
carat * color +
carat * depth +
carat * carat +
depth * depth,
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select) #some terms are duplicated
yhat_mod5
mod5 = lm(price ~
. +
carat * color +
carat * depth +
carat^2 +
depth^2,
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select) #some terms are duplicated
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
yhat_mod5
str(diamonds)
?I
mod5 = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select)
mod5
mod5 = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
yhat_mod1 = predict(mod1, diamonds_select)
yhat_mod2 = predict(mod2, diamonds_select)
yhat_mod3 = predict(mod3, diamonds_select)
yhat_mod4 = predict(mod4, diamonds_select)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_mod1 - y_select),
sd(yhat_mod2 - y_select),
sd(yhat_mod3 - y_select),
sd(yhat_mod4 - y_select)
)
names(s_e_s) = paste("mod", 1 : 4, sep = "")
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds_train)
yhat_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
yhat_select_mod1 = predict(mod1, diamonds_select)
yhat_select_mod2 = predict(mod2, diamonds_select)
yhat_select_mod3 = predict(mod3, diamonds_select)
yhat_select_mod4 = predict(mod4, diamonds_select)
y_select = diamonds_select$price #the true prices
s_e_s = c(
sd(yhat_select_mod1 - y_select),
sd(yhat_select_mod2 - y_select),
sd(yhat_select_mod3 - y_select),
sd(yhat_select_mod4 - y_select)
)
names(s_e_s) = paste("mod", 1 : 4, sep = "")
s_e_s
#find the minimum
names(which.min(s_e_s))
mod5 = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds_train)
yhat_select_mod5 = predict(mod5, diamonds_select)
s_e_s = c(s_e_s, sd(yhat_select_mod5 - y_select))
names(s_e_s)[5] = "mod5"
s_e_s
#find the minimum
names(which.min(s_e_s))
yhat_test_mod5 = predict(mod5, diamonds_test)
sd(yhat_test_mod5 - y_test)
yhat_test_mod5 = predict(mod5, diamonds_test)
y_test = diamonds_test$price #the true prices
sd(yhat_test_mod5 - y_test)
g = lm(price ~
. +
carat * color +
carat * depth +
I(carat^2) +
I(depth^2),
diamonds)
