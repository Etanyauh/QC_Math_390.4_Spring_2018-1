---
title: "Lecture 15 MATH 390.4 Queens College"
author: "Professor Adam Kapelner"
date: "March 28, 2018"
---

# Assessing overfitting in practice

Let's examine this again. This time we use one data set which is split between training and testing.

```{r}
set.seed(1003)
n = 100
beta_0 = 1
beta_1 = 5
xmin = 0
xmax = 1
p = 50
X = matrix(runif(n * p, xmin, xmax), ncol = p)

#best possible model - only one predictor matters!
h_star_x = beta_0 + beta_1 * X[,1 ]

#actual data differs due to information we don't have
epsilon = rnorm(n)
y = h_star_x + epsilon
```

Now we split $\mathbb{D}$ into training and testing. We define $K$ first, the inverse proportion of the test size.

```{r}
K = 5 #i.e. the test set is 1/5th of the entire historical dataset

#a simple algorithm to do this is to sample indices directly
test_indices = sample(1 : n, 1 / K * n)
train_indices = setdiff(1 : n, test_indices)

#now pull out the matrices and vectors based on the indices
X_train = X[train_indices, ]
y_train = y[train_indices]
X_test = X[test_indices, ]
y_test = y[test_indices]

#let's ensure these are all correct
dim(X_train)
dim(X_test)
length(y_train)
length(y_test)
```

Now let's fit the model $g$ to the training data and compute in-sample error metrics:

```{r}
mod = lm(y_train ~ ., data.frame(X_train))
summary(mod)$r.squared
sd(mod$residuals)
```

Now let's see how we do on the test data. We compute $R^2$ and $s_e$ out of sample:

```{r}
y_hat_oos = predict(mod, data.frame(X_test))
oos_residuals = y_test - y_hat_oos
1 - sum(oos_residuals^2) / sum((y_test - mean(y_test))^2)
sd(oos_residuals)
```

MUCH worse!! Why? We overfit big time...

Can we go back now and fit a new model and see how we did? NO...

So how are we supposed to fix a "bad" model? We can't unless we do something smarter. We'll get there.

# Nonlinear Linear Regression: Polynomial Regression

Let's generate a polynomial model of degree 2 ($f = h^* \in \mathcal{H}$) and let $\epsilon$ be random noise (the error due to ignorance) for $\mathbb{D}$ featuring $n = 2$.

```{r}
set.seed(1003)
n = 25
beta_0 = 1
beta_1 = 0
beta_2 = 1
x = runif(n, -2, 5)
#best possible model
h_star_x = beta_0 + beta_1 * x + beta_2 * x^2

#actual data differs due to information we don't have
epsilon = rnorm(n)
y = h_star_x + epsilon

#scatterplot it
df = data.frame(x = x, y = y, h_star_x = h_star_x)
basic = ggplot(df, aes(x, y)) +
  geom_point()
basic
```

Let's try to estimate with a line:

```{r}
linear_mod = lm(y ~ x)
b_linear = summary(linear_mod)$coef
basic + geom_abline(intercept = b_linear[1], slope = b_linear[2], col = "red")
```

The relationship is "underfit". $\mathcal{H}$ is not rich enough right now to express something close to $f(x)$. But it is better than the null model!

Now let's do a polynomial regression of degree two. Let's do so manually:

```{r}
X = as.matrix(cbind(1, x, x^2))
b = solve(t(X) %*% X) %*% t(X) %*% y
b
```

These are about the same as the $\beta_0, \beta_1$ and $\beta_2$ as defined in $f(x)$ the true model. In order to graph this, we can no longer use the routine `geom_abline`, we need to use `stat_function`.

```{r}
plot_function_degree_2 = function(x, b){
  b[1] + b[2] * x + b[3] * x^2
}

basic + stat_function(fun = plot_function_degree_2, args = list(b = b), col= "darkgreen")
```

Now let's try polynomial of degree 3:

```{r}
X = as.matrix(cbind(1, x, x^2, x^3))
b = solve(t(X) %*% X) %*% t(X) %*% y
b

plot_function_degree_3 = function(x, b){
  b[1] + b[2] * x + b[3] * x^2 + b[4] * x^3
}

basic + stat_function(fun = plot_function_degree_3, args = list(b = b), col= "darkgreen")
```
Still the same. Why? The $x^3$ term is like adding one "nonsense" predictor. One nonsense predictor marginally affects $R^2$ but it doesn't matter too much.

Now let's try polynomial of degree 8:

```{r}
X = as.matrix(cbind(1, x, x^2, x^3, x^4, x^5, x^6, x^7, x^8))
b = solve(t(X) %*% X) %*% t(X) %*% y
b

plot_function_degree_8 = function(x, b){
  b[1] + b[2] * x + b[3] * x^2 + b[4] * x^3 + b[5] * x^4 + b[6] * x^5 + b[7] * x^6 + b[8] * x^7 + b[9] * x^8 
}

basic + stat_function(fun = plot_function_degree_8, args = list(b = b), col= "darkgreen")
```

We are seeing now a little bit of "overfitting" in the edge(s). We now have $p=11$ and $n=100$. We can do a lot worse!

Let's learn how to do this in R first without having to resort to manual linear algebra. R has a function called "poly" that can be used *inside* formula declarations.

Let's first fit the degree 2 model:

```{r}
degree_2_poly_mod = lm(y ~ poly(x, 2, raw = TRUE))
b_poly_2 = coef(degree_2_poly_mod)
b_poly_2
```

Same as we got before! We use "raw" polynomials to keep them interpretable and on the same scale as the manual models we were fitting.

Now let's do polynomial of degree 13:

```{r}
degree_13_poly_mod = lm(y ~ poly(x, 13, raw = TRUE))
b_poly_13 = coef(degree_13_poly_mod)

plot_function_degree_13 = function(x, b){
  b[1] + b[2] * x + b[3] * x^2 + b[4] * x^3 + b[5] * x^4 + b[6] * x^5 + b[7] * x^6 + b[8] * x^7 + b[9] * x^8 + b[10] * x^9  + b[11] * x^10 + b[12] * x^11 + b[13] * x^12 + b[14] * x^13
}

basic + stat_function(fun = plot_function_degree_13, args = list(b = b_poly_13), col = "purple")
```

What's happening for small values of $x$ (and a bit for large values)? This is called [Runge's Phenomenon](https://en.wikipedia.org/wiki/Runge%27s_phenomenon) meaning that the boundary activity of high-order polynomials has very large derivatives. Let's go back to the same scale as before and see what's happening:

```{r}
basic + 
  coord_cartesian(xlim = c(-2, 5), ylim = c(-3, 25)) + 
  stat_function(fun = plot_function_degree_13, args = list(b = b_poly_13), col = "purple")
```


What happens during extrapolation? Let's look at the (a) linear model, (b) polynomial model with degree 2 and (c) polynomial with degree 13.

```{r}
xmin = -10
xmax = 8
basic + 
  coord_cartesian(xlim = c(xmin, xmax), ylim = c(-10, 35)) + 
  geom_abline(intercept = b_linear[1], slope = b_linear[2], col = "red") + 
  stat_function(fun = plot_function_degree_2, args = list(b = b_poly_2), col = "blue", xlim = c(xmin, xmax)) +
  stat_function(fun = plot_function_degree_13, args = list(b = b_poly_13), col = "purple", xlim = c(xmin, xmax))
```

Polynomial models have *TERRIBLE* extrapolation ability - totally unpredictable.

Can we achieve $R^2 = 100\%$ using polynomial regression? Yes. Here's an example in one dimension. These are called "interpolation polynomials". In one dimension, as long as the $x$ values are distinct, $n$ data point can be fit by a $n - 1$ degree polynomial. Here's an example with a few data points:

```{r}
set.seed(1003)
n = 5
beta_0 = 1
beta_1 = 0
beta_2 = 1
x = runif(n)
y = runif(n)

#scatterplot it
df = data.frame(x = x, y = y, h_star_x = h_star_x)
basic = ggplot(df, aes(x, y)) +
  geom_point()
basic
```

Now fit polynomial models:

```{r}
degree_4_poly_mod = lm(y ~ poly(x, 4, raw = TRUE))
b_poly_4 = coef(degree_4_poly_mod)

plot_function_degree_4 = function(x, b){
  b[1] + b[2] * x + b[3] * x^2 + b[4] * x^3 + b[5] * x^4
}

basic + stat_function(fun = plot_function_degree_4, args = list(b = b_poly_4), col = "purple")
```

Perfect fit!

```{r}
summary(degree_4_poly_mod)$r.squared
```

This is the same thing we've seen before! If $n = p + 1$, then the design matrix is square and there is no need to project onto a lower dimensional subspace. To estimate the linear model, one only needs to solve $n$ equations with $n$ unknowns.

My recommendations:
1) Keep polynomial degree low. Preferably 2. Anything past 2 is not interpretable anyway. We didn't talk about "interpretability" of models yet, but you get the idea.
2) Be very careful not to extrapolate: make sure future predictions have the measurements within range of the training data $\mathbb{D}$. Extrapolations are going to be very, very inaccurate. Polynomial regressions I'm sure have gotten data scientists fired before.


# Linear Models with Interaction Terms

Let's take a look at some data about diamonds

```{r}
data(diamonds) #from the ggplot2 package
?diamonds
str(diamonds)
summary(diamonds)
```

The natural response is price:

```{r}
ggplot(diamonds) + geom_histogram(aes(price), binwidth = 200)
mean(diamonds$price)
sd(diamonds$price)
```


A natural increasing relationship will likely be found between weight and price. Let's see it visually:

```{r}
base = ggplot(diamonds, aes(x = carat, y = price))
base + geom_point()
```

Let's see a best guess linear relationship:

```{r}
mod = lm(price ~ carat, diamonds)
b = coef(mod)
summary(mod)$r.squared
summary(mod)$sigma
base + geom_point() + geom_abline(intercept = b[1], slope = b[2], col = "green")
```

Let us add a third variable to this plot, color, a metric about the "yellowness" of the diamond. This is an ordinal categorical variable ranging from D (most clear i.e. best) to J (most yellow in this dataset i.e. worst).


```{r}
base +
  geom_point(aes(col = color)) + scale_color_brewer(type = "div")
```

We can look at this with faceting too:

```{r}
base +
  geom_point() +
  facet_wrap(~ color, ncol = 3)
```


What do we see here? It looks like the slope of the price vs. carat linear model is affected by color. For instance, the "D" color diamonds' price increases much faster as weight increases than the "E" color diamonds' price increases in weight, etc. Why do you think this is?

We can picture two of these linear models below by fitting two submodels, one for D and one for J:

```{r}
mod_D = lm(price ~ carat, subset(diamonds, color == "D"))
b_D = coef(mod_D)
mod_J = lm(price ~ carat, subset(diamonds, color == "J"))
b_J = coef(mod_J)

base +
  geom_point(aes(col = color)) + scale_color_brewer(type = "div") +
  geom_abline(intercept = b_D[1], slope = b_D[2]) +
  geom_abline(intercept = b_J[1], slope = b_J[2])
```

This indicates a separate intercept and carat-slope for each color. How is this done? Interacting carat and slope:

```{r}
diamonds$color = factor(as.character(diamonds$color)) #I don't know why I needed to do this...
mod = lm(price ~ carat * color, diamonds)
coef(mod)
summary(mod)$r.squared
summary(mod)$sigma
```

The reference category is color D. This means every other color should start lower and have a lower slope. This is about what we see above.

Let's fit a model with just one slope and differential intercepts:

```{r}
mod = lm(price ~ carat + color, diamonds)
coef(mod)
summary(mod)$r.squared
summary(mod)$sigma
```

Lesson: allowing for this interaction is a small improvement, but an improvement nevertheless. Note that we do not have the tools to test this improvement and ascertain its statistical significance.

Let's take a look at carat with another variable, depth, a continuous predictor. High depth indicates diamonds are skinny and tall; low depth indicates diamonds are flat like a pancake.

```{r}
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point(aes(col = depth), lwd = 0.5) + scale_colour_gradientn(colours = rainbow(5))
```

It seems people like flatter diamonds and are willing to pay more per carat. Let's see this in the regression:

```{r}
mod = lm(price ~ carat * depth, diamonds)
coef(mod)
summary(mod)$r.squared
summary(mod)$sigma
```

If carat increases by one unit, how much does price increase by?

Is this better than the model without the interaction?

```{r}
mod = lm(price ~ carat + depth, diamonds)
summary(mod)$r.squared
summary(mod)$sigma
```

Yes this extra degree of freedom seems to be worth it. Note that we do not have the tools to test this improvement and ascertain its statistical significance.

# Model Selection

We have now covered non-linearities (e.g. polynomial terms) and interactions. A new complication now clearly emerges. If I have $p$ predictors, there are many linear least squares models I can build (considering non-linear least squares models makes the space of models even larger!!)

For instance, here are a bunch of models:

```{r}
lm(price ~ carat + depth, diamonds) #using a subset of the features
lm(price ~ ., diamonds) #using a subset of the features
```

